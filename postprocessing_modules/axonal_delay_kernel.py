
import warnings
import numpy as np
import scipy
from matplotlib.widgets import Button
from mpl_toolkits.axes_grid1 import make_axes_locatable
from numpy.typing import NDArray
from typing import Tuple
from helper_functions.load_cell_distributions import compute_distribution
from helper_functions.cell_type_lib import CellType, get_cell_count, get_cell_coordinate_bounds
import pathlib
import h5py
from helper_functions import __file__
import matplotlib.pyplot as plt

MODULE_BASE = pathlib.Path(__file__).parent.parent


class AxonalDelayKernel(object):
    """
    AxonalDelayKernel is a class designed to postprocess axonal delay simulations (those by AxonalDelayRunner).
    THe class is initialized empty, and loaded with delay and z value data from simulation result files, directly
    as lists of values, or loaded from a previously computed AxonalDelayKernel that has been archived. AxonalDelayKernel
    then computes the spike density histogram, followed by an interpolated smooth kernel if desired. Integrated (dynamic)
    plotting functions are included to visualize kernels
    """

    def __init__(self):
        """
        Initializes an AxonalDelayKernel. All persistent variables are set to None or empty strings.
        
        Instance Variables:
            - delays: delay values organized in lists by cell subtype.
            - zs: z values corresponding the delay values in delays.
            - density (bool): True if kernel values should be density values in um^-1 ms^-1.
            - theta: Electric field polar angle.
            - gradient: Electric field gradient.
            - intensity: Electric field intensity.
            - loaded (bool): True if delay, z, and metadata is loaded.
            - t_bins: Bin edges for both histogram t-axis.
            - z_bins: Bin edges for average cell histogram z-axis.
            - t_bin_centers: Bin centers for both histogram t-axis.
            - z_bin_centers: Bin centers for average cell histogram z-axis.
            - z_bins_layer: Bin edges for layer population histogram z-axis.
            - z_bin_layer_centers: Bin centers for layer population histogram z-axis.
            - t_kernel: Bin centers for both smoothed kernel t-axis.
            - z_kernel: Bin centers for average cell smoothed kernel z-axis.
            - z_layer: Bin centers for layer population smoothed kernel z-axis.
            - z_layer_edges: Bin edges for layer population smoothed kernel z-axis.
            - subtype_histograms: list of histograms for each cell subtype summed together to form the average cell histogram.
            - subtype_labels: list of cell names of cell subtypes summed together to form the average cell histogram.
            - cell_histogram: Average cell spike density histogram.
            - layer_histogram: Layer population spike density histogram.
            - cell_kernel: Smoothed interpolated average cell spike density histogram.
            - layer_kernel: Smoothed interpolated layer population spike density histogram.
            - clabel: Label string for histogram units.
            - plots (list): List of figure objects generated by this instance.
            - param_path: Path to electric field parameter file.
            - data_path_list: List of paths to delay and z value data for each cell subtype.
            - LAYER: Layer name (L23, L23_inh, L4, L4_inh, L5, L5_inh).
            - cell_distribution_type: Layer string (L23, L23_inh, L4, L4_inh, L5, L5_inh) that determines cortical depth distribution for the population.
            - layer_num_morphs: Number of morphologies per cell subtype over which delay and z value histograms are averaged.
            - NUM_PHI_ROTATIONS: Number of cell rotation orientations over which delay and z value histograms are averaged.

        """
        self.delays = None
        self.zs = None
        self.density = None
        self.theta = None
        self.gradient = None
        self.intensity = None
        self.loaded = False
        self.t_bins = None
        self.z_bins = None
        self.t_bin_centers = None
        self.z_bin_centers = None
        self.z_bins_layer = None
        self.z_bin_layer_centers = None
        self.t_kernel = None
        self.z_kernel = None
        self.z_layer = None
        self.z_layer_edges = None
        self.subtype_histograms = None
        self.subtype_labels = None
        self.cell_histogram = None
        self.layer_histogram = None
        self.cell_kernel = None
        self.layer_kernel = None
        self.clabel = None
        self.plots = []
        self.param_path = None
        self.data_path_list = None
        self.LAYER = None
        self.cell_distribution_type = None
        self.layer_num_morphs = None
        self.NUM_PHI_ROTATIONS = None

    def load_data(self, parameter_path, data_path_list: list, cell_distribution_type: str, theta=None, gradient=None, intensity=None, param_idx: int = None):
        """
        Loads axonal delay simulation data in order to compute an AxonalDelayKernel. Input data includes a list of hdf5
        file paths corresponding to all cell subtypes which make up the layer desired for kernel calculation. The spike
        density kernels are calculated for a set of electric field theta, gradient, and intensity, or an index
        corresponding to a parameter set in the provided parameter file can determine the electric field parameters.
        Either a parameter index or all three electric field parameters must be provided.

        :param parameter_path: Path to hdf5 file containing electric field parameters (used to generate axonal delay simulations).
        :param data_path_list: List of paths to hdf5 files containing delay and z values for each component cell subtype averaged for this layer.
        :param cell_distribution_type: Layer string (L23, L23_inh, L4, L4_inh, L5, L5_inh) that determines cortical depth distribution for the population.
        :param theta: Polar angle.
        :param gradient: Electric field gradient.
        :param intensity: Electric field intensity.
        :param param_idx: Parameter index corresponding to a row in the parameter file.
        """
        self.param_path = parameter_path
        self.data_path_list = data_path_list
        self.LAYER = data_path_list[0].stem.split('_')[0]
        self.cell_distribution_type = cell_distribution_type
        self.subtype_labels = []
        self.layer_num_morphs = {}
        for data_path in data_path_list:
            subtype = data_path.stem.split('_')[1]
            electric_type = data_path.stem.split('_')[2]
            cell_label = f"{self.LAYER}_{subtype}_{electric_type}"
            self.layer_num_morphs[cell_label] = len(CellType.cell_ids[cell_label])
            self.subtype_labels.append(cell_label)
        self.NUM_PHI_ROTATIONS = 60

        if param_idx is None:
            assert (theta is not None) and (gradient is not None) and (intensity is not None), 'If param_idx is not given, define theta, gradient and intensity'
            self.theta = theta
            self.gradient = gradient
            self.intensity = intensity

            # Load parameters
            with h5py.File(self.param_path, 'r') as f_param:
                params = f_param['params'][:]

            mask_theta = abs(theta - params[:, 0]) == min(abs(theta - params[:, 0]))
            mask_grad = abs(gradient - params[:, 1]) == min(abs(gradient - params[:, 1]))
            mask_amp = abs(intensity - params[:, 2]) == min(abs(intensity - params[:, 2]))
            mask = mask_theta & mask_grad & mask_amp
            param_idx = np.where(mask)[0][0]
        else:
            with h5py.File(self.param_path, 'r') as f_param:
                self.theta, self.gradient, self.intensity = f_param['params'][param_idx, :].astype('float64')

        # Load Data
        self.delays = []
        self.zs = []

        for delay_file in self.data_path_list:
            with h5py.File(delay_file, 'r') as f_delay:
                delays = f_delay['delay'][param_idx, :].astype('float64')
                zs = f_delay['z'][param_idx, :].astype('float64')
            mask_delays = np.where(abs(delays - (-1)) != np.min(abs(delays - (-1))))[0]
            self.delays.append(delays[mask_delays])
            self.zs.append(zs[mask_delays])

        self.loaded = True

    def load_data_direct(self, layer, delays: list[list], zs: list[list], cell_type_list: list[str], layer_num_morphs,
                         num_phi_rotations, cell_distribution_type, theta=None, gradient=None, intensity=None):
        """
        Loads the delay and z value data directly by handing in values as parameters.
        :param layer: Layer string name (L23, L23_inh, L4, L4_inh, L5, L5_inh)
        :param delays: List containing lists of delay values (one list per cell subtype)
        :param zs: List containing lists of z values corresponding to the values in delays
        :param cell_type_list: list of string names of cell types corresponding to each list in delays and zs
        :param layer_num_morphs: Dictionary containing <cell name>: <number of morphologies to average over>
        :param num_phi_rotations: Number of phi rotations to average over
        :param cell_distribution_type: string name like layer, that indicates what cortical depth distribution to use
        :param theta: Polar angle
        :param gradient: Electric field gradient
        :param intensity: Electric field intensity
        """
        self.LAYER = layer
        self.cell_distribution_type = cell_distribution_type
        self.layer_num_morphs = layer_num_morphs
        self.subtype_labels = cell_type_list
        self.NUM_PHI_ROTATIONS = num_phi_rotations
        self.delays = delays
        self.zs = zs
        self.loaded = True
        self.theta = theta
        self.gradient = gradient
        self.intensity = intensity

    def calculate_histogram(self, z_step, t_step, density=True, scaling_factor=1.0) -> Tuple[NDArray, NDArray]:
        """
        Computes and returns the average cell and layer population spike density histograms from delay and z values
        with given bin size. Returns the cell and layer histograms.

        :param z_step: z-bin size in micrometers.
        :param t_step: t-bin size in ms.
        :param density: Boolean if histogram values are reported  um^-1 ms^-1.
        :param scaling_factor: Scaling factor to the histrogram heights.

        :returns: cell_histogram (NDArray), layer_histogram (NDArray)
        """
        assert self.loaded, 'Load Data before calculating histogram.'
        self.density = density
        coordinate_limits = get_cell_coordinate_bounds(layer=self.LAYER)
        z_max = coordinate_limits[1][2] // 100 * 100 + 100
        z_min = coordinate_limits[0][2] // 100 * 100 - 100
        largest_extreme = np.max([np.abs(z_min), np.abs(z_max)])
        self.z_bins = np.arange(-largest_extreme, largest_extreme + z_step, z_step)
        self.z_bin_centers = (self.z_bins[1:] + self.z_bins[:-1]) / 2
        t_min = 0.0
        t_max = 2.0
        self.t_bins = np.arange(t_min, t_max + t_step, t_step)
        self.t_bin_centers = (self.t_bins[1:] + self.t_bins[:-1]) / 2
        self.subtype_histograms = []

        # #### Calculate Histogram ####
        self.cell_histogram = np.zeros(shape=(len(self.z_bins) - 1, len(self.t_bins) - 1))
        for cell_delay, cell_z, cell_name in zip(self.delays, self.zs, self.subtype_labels):
            hist, _, _ = np.histogram2d(cell_z, cell_delay, [self.z_bins, self.t_bins])
            hist *= CellType.cell_type_morphology_ratios[self.LAYER][cell_name.split('_')[1]][cell_name.split('_')[2]]
            hist /= (self.layer_num_morphs[cell_name] * self.NUM_PHI_ROTATIONS)
            if density:
                hist = hist / (abs(np.diff(self.z_bins)[0]) * t_step)
                self.clabel = 'Spike Density\n($ms^{-1}$ $\mu$$m^{-1}$)'
            else:
                self.clabel = 'Spike Count'
            self.subtype_histograms.append(hist)
            self.cell_histogram += hist

        self.cell_histogram = self.cell_histogram * scaling_factor

        cell_density, self.z_bin_layer_centers, self.z_bins_layer, _, _, _ = compute_distribution(
            self.cell_distribution_type,
            z_step,
            micrometers=True,
        )
        self.layer_histogram = np.empty(shape=(len(self.z_bin_layer_centers), len(self.t_bin_centers)))
        for col in range(self.layer_histogram.shape[1]):
            # hist_crosscut_convolve = self.cell_histogram[::-1, col]  # Invert axis (+1400 -> -1400) for convolution
            self.layer_histogram[:, col] = scipy.signal.correlate(cell_density, self.cell_histogram[:, col], mode='same')

        return self.cell_histogram, self.layer_histogram

    def smooth_kernel(self, z_step=10, t_step=0.01, method='pchip') -> Tuple[NDArray, NDArray]:
        """
        Interpolates the average cell and layer population histograms to the provided z and t steps. Default uses the
        pchip interpolator. Other options follow from scipy.interpolate.RegularGridInterpolator.

        :param z_step: z-step in micrometers.
        :param t_step: t-step in ms.
        :param method: Interpolation method handed to scipy.interpolate.RegularGridInterpolator.

        :returns:
            cell_kernel (NDArray): Interpolated average cell kernel, layer_kernel (NDArray): Interpolated layer population kernel.
        """
        assert self.cell_histogram is not None, 'No Cell Histogram Found'
        assert self.layer_histogram is not None, 'No Layer Histogram Found'

        if not self.density:
            warnings.warn(f"Warning: Interpolating when density=False results in disruption to kernel sum.")
        self.t_kernel = np.arange(self.t_bin_centers[0], self.t_bin_centers[-1] + t_step, t_step)
        self.t_kernel[-1] = self.t_bin_centers[-1]
        self.z_kernel = np.arange(self.z_bin_centers[0], self.z_bin_centers[-1] + z_step, z_step)
        self.z_kernel[-1] = self.z_bin_centers[-1]
        self.z_layer = np.arange(0 - z_step / 2, -CellType.column_depth, -z_step)
        self.z_layer_edges = np.arange(0, -CellType.column_depth - z_step, -z_step)
        # Perform Interpolation to produce cell kernel
        points = (self.t_bin_centers, self.z_bin_centers)
        interpolator = scipy.interpolate.RegularGridInterpolator(points, self.cell_histogram.T, method=method, bounds_error=False, fill_value = None)
        t_mesh, z_mesh = np.meshgrid(self.t_kernel, self.z_kernel, indexing='ij')
        points_eval = (t_mesh, z_mesh)
        self.cell_kernel = interpolator(points_eval).T

        # Perform Interpolation to produce layer kernel
        points_layer = (self.t_bin_centers, self.z_bin_layer_centers)
        interpolator_layer = scipy.interpolate.RegularGridInterpolator(points_layer, self.layer_histogram.T, method='slinear', bounds_error=False, fill_value = None)
        t_mesh_layer, z_mesh_layer = np.meshgrid(self.t_kernel, self.z_layer, indexing='ij')
        points_eval_layer = (t_mesh_layer, z_mesh_layer)
        self.layer_kernel = interpolator_layer(points_eval_layer).T

        return self.cell_kernel, self.layer_kernel

    def load_kernel_from_file(self, param_path: pathlib.Path, data_path: pathlib.Path, source_layer_name: str, theta, gradient, intensity):
        """
        Loads the AxonalDelayKernel from precomputed save-file. A hdf5 file containing kernels precomputed for this
        cell type and all parameter sets is required to reconstruct the kernel object. Archive files contain all
        metadata attributes and all histograms and smoothed kernels, stored as three-dimensional datastructures with
        shape = (number of parameter sets, z-axis, t-axis).

        :param param_path: Path to the electric field parameter file.
        :param data_path: Path to the hdf5 file containing the AxonalDelayKernel.
        :param source_layer_name: Layer name string of the kernel (L23, L23_inh, L4, L4_inh, L5, L5_inh).
        :param theta: Polar angle.
        :param gradient: Electric field gradient.
        :param intensity: Electric field intensity.
        """
        assert source_layer_name in ['L23', 'L23_inh', 'L4', 'L4_inh', 'L5', 'L5_inh'], 'source_layer must be L23, L23_inh, L4, L4_inh, L5, or L5_inh'

        self.LAYER = source_layer_name.split('_')[0]
        self.param_path = param_path
        self.theta = theta
        self.gradient = gradient
        self.intensity = intensity
        with h5py.File(self.param_path, 'r') as f_param:
            params = f_param['params'][:]

        mask_theta = abs(theta - params[:, 0]) == min(abs(theta - params[:, 0]))
        mask_grad = abs(gradient - params[:, 1]) == min(abs(gradient - params[:, 1]))
        mask_amp = abs(intensity - params[:, 2]) == min(abs(intensity - params[:, 2]))
        mask = mask_theta & mask_grad & mask_amp
        param_idx = np.where(mask)[0][0]

        with h5py.File(data_path, 'r') as f_load:
            self.cell_histogram = f_load['cell_histograms'][param_idx, :, :].astype('float64')
            self.layer_histogram = f_load['layer_histograms'][param_idx, :, :].astype('float64')
            self.layer_kernel = f_load['layer_kernels'][param_idx, :, :].astype('float64')
            self.cell_kernel = f_load['cell_kernels'][param_idx, :, :].astype('float64')
            self.t_bin_centers = f_load['t_bin_centers'][:].astype('float64')
            self.t_bins = f_load['t_bins'][:].astype('float64')
            self.t_kernel = f_load['t_kernel'][:].astype('float64')
            self.z_bins = f_load['z_bins'][:].astype('float64')
            self.z_bins_layer = f_load['z_bins_layer'][:].astype('float64')
            self.z_bin_centers = f_load['z_bin_centers'][:].astype('float64')
            self.z_bin_layer_centers = f_load['z_bin_layer_centers'][:].astype('float64')
            self.z_kernel = f_load['z_kernel'][:].astype('float64')
            self.z_layer = f_load['z_layer'][:].astype('float64')
            self.z_layer_edges = f_load['z_layer_edges'][:].astype('float64')
            self.density = f_load['density'][()]

        if self.density:
            self.clabel = 'Spike Density\n($ms^{-1}$ $\mu$$m^{-1}$)'
        else:
            self.clabel = 'Spike Count'

    def plot_avg_cell_kernel(self, histogram=True, dynamic=False, crosscuts=False, cmap='viridis', vmax=None) -> plt.Figure:
        """
        PLots the average cell kernel. Optionally the histogram or interpolated kernel may be plotted, the depth
        axis may be plotted as normalized cortical depth, and crosscuts of the 2D kernel may be displayed with clickable
        dynamic protocol to change the time and z values at which to plot crosscuts.

        :param histogram: Boolean if the histogram should be plotted, else the interpolated kernel is plotted.
        :param dynamic: Boolean if clickable functionality on the kernel surface should be included (with crosscuts).
        :param crosscuts: Boolean if crosscuts of the kernel in time and depth axes should be plotted.
        :param cmap: Colormap to display kernel surface.
        :param vmax: Maximum value to normalize colormap.

        :return: Figure object
        """
        if histogram:
            assert self.cell_histogram is not None, 'Histogram Has not Been Computed'
            color_x = (self.t_bins[:-1] + self.t_bins[1:]) / 2
            color_y = (self.z_bins[:-1] + self.z_bins[1:]) / 2
            color_surf = self.cell_histogram
        else:
            assert self.cell_kernel is not None, 'Kernel Has not Been Computed'
            color_x = self.t_kernel
            color_y = self.z_kernel
            color_surf = self.cell_kernel

        if vmax is None:
            v_max = np.max(color_surf)
        else:
            v_max = vmax

        if crosscuts:
            self.plots.append(DynamicKernelPlot(
                color_x,
                color_y,
                color_surf,
                self.t_bins,
                self.z_bins,
                self.cell_histogram
            ))
            self.plots[-1].plot(f'{self.LAYER}', self.theta, self.gradient, self.intensity, self.clabel, cmap, v_max, dynamic)
            figobj = self.plots[-1].fig
        else:
            figobj = plt.figure(figsize=(8.5, 5))
            plt.pcolor(color_x, color_y, color_surf, cmap=cmap, vmin=0, vmax=v_max)
            plt.colorbar(label=self.clabel, location='right')
            plt.xlabel('Time (ms)')
            plt.tick_params(bottom=True, top=False, left=True, right=False, labelbottom=True, labeltop=False, labelleft=True, labelright=False)
            # plt.gca().yaxis.set_label_position("right")
            plt.ylabel('z w.r.t Soma ($\mu$m)')
            plt.tight_layout()

        return figobj

    def plot_avg_layer_kernel(self, histogram=True, normalized_depth=False, dynamic=False, crosscuts=False, cmap='viridis', vmax=None) -> plt.Figure:
        """
        PLots the layer population kernel. Optionally the histogram or interpolated kernel may be plotted, the depth
        axis may be plotted as normalized cortical depth, and crosscuts of the 2D kernel may be displayed with clickable
        dynamic protocol to change the time and z values at which to plot crosscuts.

        :param histogram: Boolean if the histogram should be plotted, else the interpolated kernel is plotted.
        :param normalized_depth: Boolean if the depth axis should be normalized, else is plotted in micrometers.
        :param dynamic: Boolean if clickable functionality on the kernel surface should be included (with crosscuts).
        :param crosscuts: Boolean if crosscuts of the kernel in time and depth axes should be plotted.
        :param cmap: Colormap to display kernel surface.
        :param vmax: Maximum value to normalize colormap.

        :return: Figure object
        """
        if histogram:
            assert self.layer_histogram is not None, 'Histogram Has not Been Computed'
            color_x = self.t_bin_centers
            color_y = self.z_bin_layer_centers
            color_surf = self.layer_histogram
        else:
            assert self.layer_kernel is not None, 'Kernel Has not Been Computed'
            color_x = self.t_kernel
            color_y = self.z_layer
            color_surf = self.layer_kernel

        if vmax is None:
            v_max = np.max(color_surf)
        else:
            v_max = vmax

        if crosscuts and normalized_depth:
            self.plots.append(DynamicKernelPlot(color_x, color_y / CellType.column_depth, color_surf))
            self.plots[-1].plot(f'{self.LAYER}', self.theta, self.gradient, self.intensity, self.clabel, cmap, v_max, dynamic)
            figobj = self.plots[-1].fig
        elif crosscuts and (not normalized_depth):
            self.plots.append(DynamicKernelPlot(color_x, color_y, color_surf))
            self.plots[-1].plot(f'{self.LAYER}', self.theta, self.gradient, self.intensity, self.clabel, cmap, v_max, dynamic)
            figobj = self.plots[-1].fig
        elif (not crosscuts) and normalized_depth:
            figobj = plt.figure(figsize=(8.5, 5))
            plt.pcolor(color_x, color_y / CellType.column_depth, color_surf, cmap=cmap, vmin=0, vmax=v_max)
            plt.colorbar(label=self.clabel)
            plt.xlabel('Time (ms)')
            plt.ylabel('Normalized Cortical Depth')
            plt.ylim(bottom=1.0, top=0.0)
            plt.tight_layout()
        else:
            figobj = plt.figure(figsize=(8.5, 5))
            plt.pcolor(color_x, color_y, color_surf, cmap=cmap, vmin=0, vmax=v_max)
            plt.colorbar(label=self.clabel, location='right')
            plt.xlabel('Time (ms)')
            plt.ylabel('Cortical Depth ($\mu$m)')
            plt.tick_params(bottom=True, top=False, left=True, right=False, labelbottom=True, labeltop=False,
                            labelleft=True, labelright=False)
            # plt.gca().yaxis.set_label_position("right")
            plt.ylim(bottom=-CellType.column_depth, top=0.0)
            plt.tight_layout()

        return figobj

    def plot_kernel_3d(self):
        """
        Plots the interpolated average cell kernel as a surface above the x-y plane.
        """
        cmap = 'viridis'
        fig2 = plt.figure()
        ax_3d = fig2.add_subplot(projection='3d')
        tt, zz = np.meshgrid(self.t_kernel, self.z_kernel)
        surf = ax_3d.plot_surface(tt, zz, self.cell_kernel, cmap=cmap, linewidth=0, antialiased=False, rcount=100,
                                  ccount=100, vmin=0, vmax=np.max(self.cell_kernel))
        ax_3d.set_xlabel('t (ms)')
        ax_3d.set_ylabel('z ($\mu$m)')
        ax_3d.set_zticklabels([])
        plt.colorbar(surf, ax=ax_3d, shrink=0.8)


def get_axonal_delay_kernel(source_layer_name: str, delay_z_folder: pathlib.Path, precomputed_kernels_folder: pathlib.Path,
                            theta, gradient, intensity, z_step=100, t_step=0.1, smooth_z_step=1, smooth_t_step=0.005,
                            density=True, multiplier=1.0, compute_fresh=False) -> AxonalDelayKernel:
    """
    Wrapper function that computes are loads AxonalDelayKernel object from save file for the provided source layer,
    electric field parameters, and step sizes.

    :param source_layer_name: Short name of upstream source population (L23, L23_inh, L4_inh, L5, or L5_inh).
    :param delay_z_folder: Path to folder containing axonal delay data.
    :param precomputed_kernels_folder: Path to folder containing precomputed axonal delay kernels.
    :param theta: Polar angle.
    :param gradient: Electric field gradient.
    :param intensity: Electric field intensity.
    :param z_step: Histogram z-bin size.
    :param t_step: Histogram t-bin size.
    :param smooth_z_step: Interpolation z-step size.
    :param smooth_t_step: Interpolation t-step size.
    :param density: Boolean if the histogram is a density function.
    :param multiplier: Scaling factor to spike density surface.
    :param compute_fresh: Boolean if the AxonalDelayKernel should be forced to be computed fresh from delay/z values.

    :return: AxonalDelayKernel object populated with hitogram, smooth kernel, and associated metadata.
    """
    data_files = list(delay_z_folder.iterdir())
    if source_layer_name == 'L5':
        scaling_factor = 1.0
        cell_distribution_type = 'L5'
        cell_morphology_type = 'L5'
    elif source_layer_name == 'L5_inh':
        scaling_factor = get_cell_count('L5_inh') / get_cell_count('L5')
        cell_distribution_type = 'L5'
        cell_morphology_type = 'L4'
    elif source_layer_name == 'L4':
        cell_distribution_type = 'L4'
        scaling_factor = get_cell_count('L4') / get_cell_count('L5')
        cell_morphology_type = 'L23'
    elif source_layer_name == 'L4_inh':
        scaling_factor = get_cell_count('L4_inh') / get_cell_count('L5')
        cell_distribution_type = 'L4'
        cell_morphology_type = 'L4'
    elif source_layer_name == 'L23':
        scaling_factor = get_cell_count('L23') / get_cell_count('L5')
        cell_distribution_type = 'L23'
        cell_morphology_type = 'L23'
    elif source_layer_name == 'L23_inh':
        scaling_factor = get_cell_count('L23_inh') / get_cell_count('L5')
        cell_distribution_type = 'L23'
        cell_morphology_type = 'L4'
    else:
        raise AttributeError('source_layer must be L23, L23_inh, L4_inh, L5, or L5_inh')
    file_list = [pth for pth in data_files if pth.stem.split('_')[0] == cell_morphology_type]
    param_file = MODULE_BASE.joinpath('reference_data/axonal_delay_reduced_biphasic_params.hdf5')
    if density:
        dens_label = 'density'
    else:
        dens_label = 'histogram'
    t_label = f'{t_step:.3}'.replace('.', 'p')
    merged_file = precomputed_kernels_folder.joinpath(f'axonal_delay_kernels_{source_layer_name}_zstep_{z_step}_tstep_{t_label}_{dens_label}.hdf5')
    if not merged_file.is_file() or compute_fresh:
        # Compute Axonal Delay Kernel and Interpolated Kernel From Scratch
        kernel = AxonalDelayKernel()
        kernel.load_data(
            parameter_path=param_file,
            data_path_list=file_list,
            cell_distribution_type=cell_distribution_type,
            theta=theta,
            gradient=gradient,
            intensity=intensity
        )
        kernel.calculate_histogram(
            z_step=z_step,
            t_step=t_step,
            density=density,
            scaling_factor=scaling_factor * multiplier
        )
        kernel.smooth_kernel(
            z_step=smooth_z_step,
            t_step=smooth_t_step
        )
    else:
        # Get Precomputed Axonal Delay Kernel from File
        kernel = AxonalDelayKernel()
        kernel.load_kernel_from_file(
            param_path=param_file,
            data_path=merged_file,
            source_layer_name=source_layer_name,
            theta=theta,
            gradient=gradient,
            intensity=intensity,
        )
        if not (np.isclose(abs(np.diff(kernel.z_kernel)[0]), smooth_z_step) and np.isclose(abs(np.diff(kernel.t_kernel)[0]), smooth_t_step)):
            kernel.smooth_kernel(
                z_step=smooth_z_step,
                t_step=smooth_t_step
            )

    return kernel


class DynamicKernelPlot(object):
    """
    DynamicKernelPlot is a plotting wrapper that contains persistent variables to hold dynamic processing objects.
    The plot is designed to display the kernel (or histogram) alongside a crosscut of the 2D surface when t is constant
    and another when z is constant. The user selects these constants by clicking on the colorplot surface, upon which
    the crosscuts are updated and the crosshair moves on the colorplot overlay. An overlay of coordinate values appears
    when hovering the cursor over the colorplot (For application, see AxonalDelayKernel plot functions with
    dynamic=True).
    """

    def __init__(self, t_smooth, z_smooth, kernel, t_bins=None, z_bins=None, histogram=None):
        """
        Initializes a DynamicKernelPlot, sets initial data from parameters and metadata to None.

        :param t_smooth: Interpolated kernel t-axis.
        :param z_smooth: Interpolated kernel z-axis.
        :param kernel: Interpolated kernel array.
        :param t_bins: Histogram t-bins.
        :param z_bins: Histogram z-bins.
        :param histogram: Histogram array.

        Instance Variables:
            - fig: Figure object.
            - cursor: Cursor object.
            - click_processor: ButtonClickProcessor object.
            - crosscut_t_smooth: Crosscut of interpolated kernel at fixed t.
            - crosscut_z_smooth: Crosscut of interpolated kernel at fixed z.
            - crosscut_hist_t: Crosscut of histogram at fixed t.
            - crosscut_hist_z: Crosscut of histogram at fixed z.
            - hline: Horizontal line artist.
            - vline: Vertical line artist.
            - ax_colorplt: Figure axis of kernel colorplot.
            - ax_colorbar: Figure axis of kernel colorbar.
            - ax_fixed_t: Figure axis of fixed t crosscut.
            - ax_fixed_z: Figure axis of fixed z crosscut.
        """
        self.t_smooth = t_smooth
        self.z_smooth = z_smooth
        self.kernel = kernel
        self.t_bins = t_bins
        self.z_bins = z_bins
        self.histogram = histogram

        self.fig = None
        self.cursor = None
        self.click_processor = None
        self.crosscut_t_smooth = None
        self.crosscut_z_smooth = None
        self.crosscut_hist_t = None
        self.crosscut_hist_z = None
        self.hline = None
        self.vline = None
        self.ax_colorplt = None
        self.ax_colorbar = None
        self.ax_fixed_t = None
        self.ax_fixed_z = None

    def plot(self, cell_label, theta, gradient, intensity, clabel, cmap, vmax, dynamic=False):
        """
        Plot representation of axonal delay kernel. If dynamic=True, a click watcher is set up and maintained in an
        instance variable such that clicking the colorplot updates the crosscut plots and colorplot overlay.

        :param cell_label: Cell name.
        :param theta: Electric field polar angle.
        :param gradient: Electric field gradient.
        :param intensity: Electric field intensity.
        :param clabel: Kernel units label.
        :param cmap: Colormap name.
        :param vmax: Max value to normalize colormap.
        :param dynamic: (bool) True if plot is dynamic and responds to user click.
        :return:
        """
        plot_hist = (self.t_bins is not None) and (self.z_bins is not None) and (self.histogram is not None)

        z = (self.z_smooth[0] + self.z_smooth[-1]) / 2
        t = (self.t_smooth[0] + self.t_smooth[-1]) / 2
        if np.any(self.z_smooth < 0):
            ylabel = 'Depth w.r.t. Soma ($\mu$m)'
        elif np.any(self.z_smooth > 100):
            ylabel = 'Cortical Depth ($\mu$m)'
        else:
            ylabel = 'Normalized Cortical Depth'

        if plot_hist:
            z_bin_centers = (self.z_bins[1:] + self.z_bins[:-1]) / 2
            t_bin_centers = (self.t_bins[1:] + self.t_bins[:-1]) / 2
            z_ind = np.where(np.abs(z - z_bin_centers) == np.abs(z - z_bin_centers).min())[0][0]
            t_ind = np.where(np.abs(t - t_bin_centers) == np.abs(t - t_bin_centers).min())[0][0]
            hist_z = z_bin_centers[z_ind]
            crosscut_hist_fix_z = self.histogram[z_ind, :]
            hist_t = t_bin_centers[t_ind]
            crosscut_hist_fix_t = self.histogram[:, t_ind]
            kernel_color_fix_z = 'k'
            kernel_color_fix_t = 'k'

            z_ind_smooth = np.where(np.abs(hist_z - self.z_smooth) == np.abs(hist_z - self.z_smooth).min())[0][0]
            true_z_smooth = self.z_smooth[z_ind_smooth]
            crosscut_smooth_fix_z = self.kernel[z_ind_smooth, :]

            t_ind_smooth = np.where(np.abs(t - self.t_smooth) == np.abs(t - self.t_smooth).min())[0][0]
            true_t_smooth = self.t_smooth[t_ind_smooth]
            crosscut_smooth_fix_t = self.kernel[:, t_ind_smooth]
        else:
            crosscut_hist_fix_z = None
            crosscut_hist_fix_t = None
            kernel_color_fix_z = plt.rcParams['axes.prop_cycle'].by_key()['color'][1]
            kernel_color_fix_t = plt.rcParams['axes.prop_cycle'].by_key()['color'][2]

            z_ind_smooth = np.where(np.abs(z - self.z_smooth) == np.abs(z - self.z_smooth).min())[0][0]
            true_z_smooth = self.z_smooth[z_ind_smooth]
            crosscut_smooth_fix_z = self.kernel[z_ind_smooth, :]

            t_ind_smooth = np.where(np.abs(t - self.t_smooth) == np.abs(t - self.t_smooth).min())[0][0]
            true_t_smooth = self.t_smooth[t_ind_smooth]
            crosscut_smooth_fix_t = self.kernel[:, t_ind_smooth]

        self.fig = plt.figure(figsize=(10, 10 * 2 / 3), tight_layout=True)
        self.ax_colorplt = self.fig.add_subplot(111)

        divider = make_axes_locatable(self.ax_colorplt)
        self.ax_colorbar = divider.append_axes("left", size="5%", pad=0.1)
        self.ax_fixed_z = divider.append_axes("bottom", size="100%", pad=1.25)
        self.ax_fixed_t = divider.append_axes("right", size="100%", pad=2.0)
        cplt_layer = self.ax_colorplt.pcolor(self.t_smooth, self.z_smooth, self.kernel, cmap=cmap, vmin=0, vmax=vmax)
        self.hline = self.ax_colorplt.axhline(true_z_smooth,
                                              color=plt.rcParams['axes.prop_cycle'].by_key()['color'][1],
                                              linestyle='-',
                                              linewidth=0.5)
        self.vline = self.ax_colorplt.axvline(true_t_smooth,
                                              color=plt.rcParams['axes.prop_cycle'].by_key()['color'][2],
                                              linestyle='-',
                                              linewidth=0.5)
        self.ax_colorplt.set_xticks(np.arange(0.5, self.t_smooth[-1] + 0.5, 0.5))
        self.ax_colorplt.set_xlim(self.t_smooth[0], self.t_smooth[-1])

        # self.ax_colorplt.set_ylim(np.round(self.z_smooth[0]), np.round(self.z_smooth[-1]))  # z is ascending, smallest value at bottom
        self.ax_colorplt.set_xlabel('Time (ms)')
        self.ax_colorplt.set_ylabel(ylabel)
        self.ax_colorplt.yaxis.set_label_position("right")
        self.ax_colorplt.yaxis.tick_right()
        plt.colorbar(cplt_layer, cax=self.ax_colorbar, label=clabel)
        self.ax_colorbar.yaxis.set_label_position("left")
        self.ax_colorbar.yaxis.tick_left()
        self.ax_colorplt.set_title('K(z, t)')
        plt.suptitle(f"Axonal Delay Kernel: {cell_label} | " +
                     f"($\\theta$ = {theta}, $\Delta$E = {gradient}, Intensity = {intensity})")

        self.crosscut_t_smooth = self.ax_fixed_t.plot(crosscut_smooth_fix_t, self.z_smooth,
                                                      color=kernel_color_fix_t)
        # ax2.set_ylabel('z ($\mu$m)')
        self.ax_fixed_t.set_xlim(self.ax_colorbar.get_ylim()[0], self.ax_colorbar.get_ylim()[1] * (1 + 0.1))
        self.ax_fixed_t.set_ylim(self.z_smooth[-1], self.z_smooth[-0])
        self.ax_fixed_t.set_xlabel(clabel)
        # ax_fixed_t.set_xlim(0, np.max(hist_norm, initial=1) + np.max(hist_norm, initial=1) * 0.1)
        # Rotate labels
        # for label in self.ax_fixed_t.get_xticklabels():
        #     label.set_rotation(30)
        #     label.set_ha('right')
        self.ax_fixed_t.set_title(f'R(z, t = {true_t_smooth:.2f})')
        self.crosscut_z_smooth = self.ax_fixed_z.plot(self.t_smooth, crosscut_smooth_fix_z,
                                                      color=kernel_color_fix_z)
        if plot_hist:
            self.crosscut_hist_z = self.ax_fixed_z.stairs(crosscut_hist_fix_z, self.t_bins, fill=True,
                                                          color=plt.rcParams['axes.prop_cycle'].by_key()['color'][1])
            self.crosscut_hist_t = self.ax_fixed_t.stairs(crosscut_hist_fix_t, self.z_bins, fill=True,
                                                          orientation='horizontal',
                                                          color=plt.rcParams['axes.prop_cycle'].by_key()['color'][2])
        else:
            self.crosscut_hist_z = None
            self.crosscut_hist_t = None

        # ax_fixed_z.set_ylim(0, np.max(hist_norm, initial=0.00001) + np.max(hist_norm, initial=0.00001) * 0.1)
        self.ax_fixed_z.set_xlabel('Time (ms)')
        self.ax_fixed_z.set_ylabel(clabel, labelpad=20)
        self.ax_fixed_z.set_title(f"R(z = {true_z_smooth:.2f}, t)")
        # ax_fixed_z.set_xticks(ax_colorplt.get_xticks())
        self.ax_fixed_z.set_xlim(self.ax_colorplt.get_xlim())
        self.ax_fixed_z.set_ylim(self.ax_colorbar.get_ylim()[0], self.ax_colorbar.get_ylim()[1] * (1 + 0.1))

        # ##### Setup Dynamic Plot #####
        if dynamic:
            print('Setting up Dynamic Plot')
            self.cursor = Cursor(self.ax_colorplt)
            self.fig.canvas.mpl_connect('motion_notify_event', self.cursor.on_mouse_move)
            histogram_data = (self.z_bins, self.t_bins, self.histogram, self.crosscut_hist_z,
                              self.crosscut_hist_t) if plot_hist else None
            kde_data = (self.z_smooth, self.t_smooth, self.kernel, self.crosscut_z_smooth, self.crosscut_t_smooth)
            self.click_processor = ButtonClickProcessor(
                click_axis=self.ax_colorplt,
                plot_axis_t=self.ax_fixed_t,
                plot_axis_z=self.ax_fixed_z,
                histogram_data=histogram_data,
                kde_data=kde_data,
                hline_artist=self.hline,
                vline_artist=self.vline,
                clabel=clabel
            )



class ButtonClickProcessor(object):
    """
    ButtonCLickProcesser is a click watcher for the DyanmicKernelPlot, which waits for a click on the colorplot surface,
    extracts the location of the click, and subsequently updates the overlay and crosscut plots at the chosen values.
    """

    def __init__(self, click_axis, plot_axis_t, plot_axis_z, histogram_data, kde_data, hline_artist, vline_artist,
                 clabel):
        """
        Initialized ButtonCLickProcesser instance. If histogram_data is None, plot_hist=False and the smoothed kernel is
        plotted. Otherwise, the histogram is plotted instead of the smoothed kernel. Instance variables include
        dynamic widgets that are maintained while a dynamic figure is active. A Button click watcher is set on the
        click_axis which calls process() on click.

        :param click_axis: Figure axis to be made clickable.
        :param plot_axis_t: Figure axis of fixed-t crosscut.
        :param plot_axis_z: Figure axis of fixed-z crosscut.
        :param histogram_data: Histogram values for colorplot.
        :param kde_data: Smoothed kernel values for colorplot.
        :param hline_artist: Horizontal line artist.
        :param vline_artist: Vertical line artist.
        :param clabel: Kernel units label.
        """
        x_ticks = click_axis.get_xticks()
        y_ticks = click_axis.get_yticks()
        x_lim = click_axis.get_xlim()
        y_lim = click_axis.get_ylim()
        self.figure = click_axis.figure
        self.click_axis = click_axis
        self.plot_axis_t = plot_axis_t
        self.plot_axis_z = plot_axis_z
        self.hline_artist = hline_artist
        self.vline_artist = vline_artist
        self.clabel = clabel
        if histogram_data is None:
            self.plot_hist = False
        else:
            self.plot_hist = True
            self.z_data, self.t_data, self.histogram, self.crosscut_artist_z, self.crosscut_artist_t = histogram_data
        self.z_kde, self.t_kde, self.kde_surface, self.kde_artist_z, self.kde_artist_t = kde_data

        self.button = Button(self.click_axis, label='axis_left_click')
        self.button.label.set_visible(False)
        self.click_axis.set_xticks(x_ticks)
        self.click_axis.set_yticks(y_ticks)
        self.click_axis.set_xlim(x_lim)
        self.click_axis.set_ylim(y_lim)
        self.button.on_clicked(self.process)

    def process(self, event):
        """
        Process on click of colorplot. Former crosscuts are removed and replaced with ones corresponding to those
        closest to the clicked values recovered from event data. Titles are updated to display fixed values. Vline and
        Hline artists are removed and redrawn at location of the click. Events are flushed.

        :param event: Event object containing data on click location.
        """
        # Axis has been clicked
        self.kde_artist_z[0].remove()
        self.kde_artist_t[0].remove()
        # Collect z value:
        t_click, z_click = event.xdata, event.ydata

        if self.plot_hist:
            self.crosscut_artist_z.remove()
            self.crosscut_artist_t.remove()
            # Determine crosscut histograms
            z_idx = np.where(np.abs(z_click - self.z_data) == np.abs(z_click - self.z_data).min())[0][0]
            t_idx = np.where(np.abs(t_click - self.t_data) == np.abs(t_click - self.t_data).min())[0][0]
            crosscut_histogram_z = self.histogram[z_idx, :]
            crosscut_histogram_t = self.histogram[:, t_idx]
            # Determine crosscut smooth curves
            z_idx_kde = \
            np.where(np.abs(self.z_data[z_idx] - self.z_kde) == np.abs(self.z_data[z_idx] - self.z_kde).min())[0][0]
            t_idx_kde = \
            np.where(np.abs(self.t_data[t_idx] - self.t_kde) == np.abs(self.t_data[t_idx] - self.t_kde).min())[0][0]
            data_z_kde = self.z_kde[z_idx_kde]
            data_t_kde = self.t_kde[t_idx_kde]

            self.crosscut_artist_z = self.plot_axis_z.stairs(crosscut_histogram_z, self.t_data,
                                                             color=plt.rcParams['axes.prop_cycle'].by_key()['color'][1],
                                                             fill=True)
            self.crosscut_artist_t = self.plot_axis_t.stairs(crosscut_histogram_t, self.z_data,
                                                             color=plt.rcParams['axes.prop_cycle'].by_key()['color'][2],
                                                             fill=True, orientation='horizontal')
            color_t = 'k'
            color_z = 'k'
        else:
            # Determine crosscut smooth curves
            z_idx_kde = np.where(np.abs(z_click - self.z_kde) == np.abs(z_click - self.z_kde).min())[0][0]
            t_idx_kde = np.where(np.abs(t_click - self.t_kde) == np.abs(t_click - self.t_kde).min())[0][0]
            data_z_kde = self.z_kde[z_idx_kde]
            data_t_kde = self.t_kde[t_idx_kde]

            color_t = plt.rcParams['axes.prop_cycle'].by_key()['color'][2]
            color_z = plt.rcParams['axes.prop_cycle'].by_key()['color'][1]

        crosscut_kde_z = self.kde_surface[z_idx_kde, :]
        crosscut_kde_t = self.kde_surface[:, t_idx_kde]
        self.kde_artist_z = self.plot_axis_z.plot(self.t_kde, crosscut_kde_z, color=color_z)
        self.plot_axis_z.set_xlabel('Time (ms)')
        # self.plot_axis_z.set_ylabel(self.clabel)
        self.plot_axis_z.set_title(f"K(z = {data_z_kde:.2f}, t)")

        self.kde_artist_t = self.plot_axis_t.plot(crosscut_kde_t, self.z_kde, color=color_t)
        # self.plot_axis_t.set_xlabel(self.clabel)
        self.plot_axis_t.set_title(f'K(z, t = {data_t_kde:.2f})')

        self.hline_artist.remove()
        self.vline_artist.remove()
        self.hline_artist = self.click_axis.axhline(data_z_kde,
                                                    color=plt.rcParams['axes.prop_cycle'].by_key()['color'][1],
                                                    linestyle='-', linewidth=0.5)
        self.vline_artist = self.click_axis.axvline(data_t_kde,
                                                    color=plt.rcParams['axes.prop_cycle'].by_key()['color'][2],
                                                    linestyle='-', linewidth=0.5)
        self.figure.canvas.draw()
        self.figure.canvas.flush_events()


class Cursor:
    """
    A crosshair cursor that tracks mouse position when hovering over a DynamicKernrelPlot colorplot. Hovering causes
    a movable crosshair to follow the cursor as well as an updating coordinate display overlay.
    """

    def __init__(self, axis):
        """
        Initializes Cursor instance over interactive axis. Sets crosshair initial position and text coordinate overlay.

        :param axis: Figure axis for cursor.
        """
        self.ax = axis
        self.horizontal_line = axis.axhline(color=plt.rcParams['axes.prop_cycle'].by_key()['color'][1], lw=0.8, ls='--')
        self.vertical_line = axis.axvline(color=plt.rcParams['axes.prop_cycle'].by_key()['color'][2], lw=0.8, ls='--')
        # text location in axes coordinates
        self.text = axis.text(0.45, 0.1, '', transform=axis.transAxes, color='w', fontsize=12)

    def set_cross_hair_visible(self, visible):
        """
        Sets crosshair overlay to be visible.

        :param visible: (bool) If True the crosshair is visible.

        :return: need_redraw: True if crosshair is not visible while visible=True.
        """
        need_redraw = self.horizontal_line.get_visible() != visible
        self.horizontal_line.set_visible(visible)
        self.vertical_line.set_visible(visible)
        self.text.set_visible(visible)
        return need_redraw

    def on_mouse_move(self, event):
        """
        Mouse movement watcher waits for mouse movement, and redraws crosshair and coordinate text overlay to follow
        position of mouse hover.
        :param event:
        :return:
        """
        if not event.inaxes:
            need_redraw = self.set_cross_hair_visible(False)
            if need_redraw:
                self.ax.figure.canvas.draw()
        elif event.inaxes is self.ax:
            self.set_cross_hair_visible(True)
            x, y = event.xdata, event.ydata
            # update the line positions
            self.horizontal_line.set_ydata([y])
            self.vertical_line.set_xdata([x])
            self.text.set_text(f't={x:.2f} z={y:1.2f}')
            self.ax.figure.canvas.draw()
